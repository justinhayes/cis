# Specify server locations in a SOLR_LOCATOR variable; used later in variable substitutions:
SOLR_LOCATOR : {
  # Name of solr collection
  collection : ciscollection

  # ZooKeeper ensemble
  zkHost : "hadoop0:2181/solr"

  # The maximum number of documents to send to Solr per network batch (throughput knob)
  # batchSize : 100
}

morphlines : [
  {
    id : normalizeHttpdLog
    importCommands : ["com.cloudera.**", "org.apache.solr.**"]

    commands : [
     #{ logInfo { format : "httpd input record {}", args : ["@{}"] } }
     
     # Read the CSV data
     {
        #192.168.48.60 - - [10/Jul/2012:16:15:06 -0400] "GET /shuttle/missions/sts-71/sts-71-day-11-highlights.html HTTP/1.0" 200 6626
        readCSV {
          separator : " "
          columns : ["srcip","a","b","ts","tz","verb","resource","proto","code","len"]
          ignoreFirstLine : false
          trim : false
          charset : UTF-8
        }
      }
      
      # Build raw field and then clean up unnecessary fields
      {
         java {
            imports : "import java.util.*; import java.lang.StringBuilder;"
            code: """
               //rebuild the entire raw record
               StringBuilder val = new StringBuilder();
               val.append(record.getFirstValue("srcip")).append(" ");
               val.append(record.getFirstValue("a")).append(" ");
               val.append(record.getFirstValue("b")).append(" ");
               val.append(record.getFirstValue("ts")).append(" ");
               val.append(record.getFirstValue("tz")).append(" ");
               val.append(record.getFirstValue("verb")).append(" ");
               val.append(record.getFirstValue("resource")).append(" ");
               val.append(record.getFirstValue("proto")).append(" ");
               val.append(record.getFirstValue("code")).append(" ");
               val.append(record.getFirstValue("len"));
               record.put("raw", val.toString());
               
               //remove unneeded fields from the parsed version
               record.removeAll("a");
               record.removeAll("b");
               record.removeAll("tz");
               
               //add some empty fields that are needed in the final record
               record.put("type", "httpd");
               record.put("dstip", "");
               record.put("srcport", "");
               record.put("dstport", "");
               
               return child.process(record);
            """
         }
      }
      
      # Strip leading [ from the ts field then convert it to 'yyyy-mm-dd hh:mm:ss'
      { 
         findReplace { 
            field : ts
            pattern : "["
            replacement : ""
         }
      }
      { 
         convertTimestamp { 
            field : ts
            inputFormats : ["dd/MMM/yyyy:HH:mm:ss"]
            inputTimezone : America/Los_Angeles
            outputFormat : "yyyy-MM-dd HH:mm:ss"
            outputTimezone : UTC
         } 
      }
      
      # Strip the " from verb field
      { 
         findReplace { 
            field : verb
            pattern : "\""
            replacement : ""
         }
      }
      
      # Strip the " from proto field
      { 
         findReplace { 
            field : proto
            pattern : "\""
            replacement : ""
         }
      }
      
      # Set some additional values, some of which have defaults, others of which are to remain empty
      #{
      #   addValues {
      #      type : "httpd"
      #      dstip : ""
      #      srcport : ""
      #      dstport : ""
      #   }
      #}
      
      # Put things in order in a single, tab-separated value
      #["ts","raw","type","verb","resource","code","len","srcip","dstip","srcport","dstport","proto"]
      {
         java {
            imports : "import java.util.*; import java.lang.StringBuilder;"
            code: """
               //set the len field to the empty string if it is '-'
               String len = record.getFirstValue("len").toString();
               len = "-".equals(len) ? "" : len;
               
               StringBuilder val = new StringBuilder();
               val.append(record.getFirstValue("ts")).append("\t");
               val.append(record.getFirstValue("raw")).append("\t");
               val.append(record.getFirstValue("type")).append("\t");
               val.append(record.getFirstValue("verb")).append("\t");
               val.append(record.getFirstValue("resource")).append("\t");
               val.append(record.getFirstValue("code")).append("\t");
               val.append(len).append("\t");
               val.append(record.getFirstValue("srcip")).append("\t");
               val.append(record.getFirstValue("dstip")).append("\t");
               val.append(record.getFirstValue("srcport")).append("\t");
               val.append(record.getFirstValue("dstport")).append("\t");
               val.append(record.getFirstValue("proto"));
               
               //validate that val contains a valid record; if not, then don't add a record field for it, ie:
               //	must have correct number of tabs
               //	each field must be of the correct type
               //(ts TIMESTAMP, raw STRING, type STRING, verb STRING, resource STRING, code INT, len INT, srcip STRING, dstip STRING, srcport INT, dstport INT, proto STRING)
               //2012-07-15 02:36:51     192.168.9.17 - - [14/Jul/2012:19:36:51 -0400] "GET /images/ksclogo-medium.gif HTTP/1.0" 200 5866        httpd   GET     /images/ksclogo-medium.gif      200     5866    192.168.9.17                            HTTP/1.0
               boolean valid = true;
               try {
                   Integer.parseInt(record.getFirstValue("code").toString());
               } catch (Exception ex) {
                   valid = false;
               }
               
               if (valid) {
                   record.put("record", val.toString());
               } else {
                   record.put("record2", val.toString());
               }
               
               //now remove the original fields
               record.removeAll("ts");
               record.removeAll("raw");
               record.removeAll("type");
               record.removeAll("verb");
               record.removeAll("resource");
               record.removeAll("code");
               record.removeAll("len");
               record.removeAll("srcip");
               record.removeAll("dstip");
               record.removeAll("srcport");
               record.removeAll("dstport");
               record.removeAll("proto");
               
               return child.process(record);
            """
         }
      }
      
      #{ logInfo { format : "output record {}", args : ["@{}"] } }
    ]
  }
  
  {
    id : normalizeIptablesLog
    importCommands : ["com.cloudera.**", "org.apache.solr.**"]

    commands : [
     
     # Read the CSV data
     {
        #Jul  14 12:44:51 debian kernel: IN=ra0 OUT= MAC=00:17:9a:0a:f6:44:00:08:5c:00:00:01:08:00 SRC=192.168.16.29 DST=192.168.102.181 LEN=60 TOS=0x00 PREC=0x00 TTL=51 ID=18374 DF PROTO=udp SPT=40557 DPT=51 WINDOW=5840 RES=0x00 SYN URGP=0
        readCSV {
          separator : " "
          columns : ["mon","extraspace","day","time","os","program","in","out","mac","srcip","dstip","len","tos","prec","ttl","id","df","proto","srcport","dstport","window","res","syn","urgp"]
          ignoreFirstLine : false
          trim : false
          charset : UTF-8
        }
      }
      
      # Build raw field and then clean up unnecessary fields
      {
         java {
            imports : "import java.util.*; import java.lang.StringBuilder;"
            code: """
               //rebuild the entire raw record
               StringBuilder val = new StringBuilder();
               val.append(record.getFirstValue("mon")).append(" ");
               val.append(record.getFirstValue("day")).append(" ");
               val.append(record.getFirstValue("time")).append(" ");
               val.append(record.getFirstValue("os")).append(" ");
               val.append(record.getFirstValue("program")).append(" ");
               val.append(record.getFirstValue("in")).append(" ");
               val.append(record.getFirstValue("out")).append(" ");
               val.append(record.getFirstValue("mac")).append(" ");
               val.append(record.getFirstValue("srcip")).append(" ");
               val.append(record.getFirstValue("dstip")).append(" ");
               val.append(record.getFirstValue("len")).append(" ");
               val.append(record.getFirstValue("tos")).append(" ");
               val.append(record.getFirstValue("prec")).append(" ");
               val.append(record.getFirstValue("ttl")).append(" ");
               val.append(record.getFirstValue("id")).append(" ");
               val.append(record.getFirstValue("df")).append(" ");
               val.append(record.getFirstValue("proto")).append(" ");
               val.append(record.getFirstValue("srcport")).append(" ");
               val.append(record.getFirstValue("dstport")).append(" ");
               val.append(record.getFirstValue("window")).append(" ");
               val.append(record.getFirstValue("res")).append(" ");
               val.append(record.getFirstValue("syn")).append(" ");
               val.append(record.getFirstValue("urgp"));
               record.put("raw", val.toString());
               
               //create the ts field by concatenating the year, month, day, and time fields to match this format: dd/MMM/yyyy:HH:mm:ss
               String year = "2013"; //TODO make dynamic
               record.put("ts", record.getFirstValue("day") + "/" + record.getFirstValue("mon") + "/" + year + ":" + record.getFirstValue("time"));
               
               //Take everything after the "=" in the following fields: srcip, dstip, len, proto, srcport, dstport
               //TODO do this in a substr command?
               record.replaceValues("srcip", record.getFirstValue("srcip").toString().substring(record.getFirstValue("srcip").toString().indexOf("=")+1));
               record.replaceValues("dstip", record.getFirstValue("dstip").toString().substring(record.getFirstValue("dstip").toString().indexOf("=")+1));
               record.replaceValues("len", record.getFirstValue("len").toString().substring(record.getFirstValue("len").toString().indexOf("=")+1));
               record.replaceValues("proto", record.getFirstValue("proto").toString().substring(record.getFirstValue("proto").toString().indexOf("=")+1));
               record.replaceValues("srcport", record.getFirstValue("srcport").toString().substring(record.getFirstValue("srcport").toString().indexOf("=")+1));
               record.replaceValues("dstport", record.getFirstValue("dstport").toString().substring(record.getFirstValue("dstport").toString().indexOf("=")+1));
               
               //remove unneeded fields from the parsed version
               record.removeAll("mon");
               record.removeAll("extraspace");
               record.removeAll("day");
               record.removeAll("time");
               record.removeAll("os");
               record.removeAll("program");
               record.removeAll("in");
               record.removeAll("out");
               record.removeAll("mac");
               record.removeAll("tos");
               record.removeAll("prec");
               record.removeAll("ttl");
               record.removeAll("id");
               record.removeAll("df");
               record.removeAll("window");
               record.removeAll("res");
               record.removeAll("syn");
               record.removeAll("urgp");
               
               //add some fields that are needed in the final record
               record.put("type", "iptables");
               record.put("verb", "");
               record.put("resource", "");
               record.put("code", "");
               
               return child.process(record);
            """
         }
      }
      
      # Convert ts field to 'yyyy-mm-dd hh:mm:ss'
      { 
         convertTimestamp { 
            field : ts
            inputFormats : ["dd/MMM/yyyy:HH:mm:ss"]
            inputTimezone : America/Los_Angeles
            outputFormat : "yyyy-MM-dd HH:mm:ss"
            outputTimezone : UTC
         } 
      }
      
      # Put things in order in a single, tab-separated value
      #["ts","raw","type","verb","resource","code","len","srcip","dstip","srcport","dstport","proto"]
      {
         java {
            imports : "import java.util.*; import java.lang.StringBuilder;"
            code: """
               StringBuilder val = new StringBuilder();
               val.append(record.getFirstValue("ts")).append("\t");
               val.append(record.getFirstValue("raw")).append("\t");
               val.append(record.getFirstValue("type")).append("\t");
               val.append(record.getFirstValue("verb")).append("\t");
               val.append(record.getFirstValue("resource")).append("\t");
               val.append(record.getFirstValue("code")).append("\t");
               val.append(record.getFirstValue("len")).append("\t");
               val.append(record.getFirstValue("srcip")).append("\t");
               val.append(record.getFirstValue("dstip")).append("\t");
               val.append(record.getFirstValue("srcport")).append("\t");
               val.append(record.getFirstValue("dstport")).append("\t");
               val.append(record.getFirstValue("proto"));
               
               record.removeAll("ts");
               record.removeAll("raw");
               record.removeAll("type");
               record.removeAll("verb");
               record.removeAll("resource");
               record.removeAll("code");
               record.removeAll("len");
               record.removeAll("srcip");
               record.removeAll("dstip");
               record.removeAll("srcport");
               record.removeAll("dstport");
               record.removeAll("proto");
               
               record.put("record", val.toString());
               
               return child.process(record);
            """
         }
      }
      
      #{ logInfo { format : "output record {}", args : ["@{}"] } }
    ]
  }
  
  {
    id : solrIndexer
    importCommands : ["com.cloudera.**", "org.apache.solr.**"]

    commands : [
      #{ logInfo { format : "solr input record {}", args : ["@{}"] } }
     
      # Parse the TSV data in the "record" field
      # TODO use this if we are using a newer morphlines version (>= 0.9); if not, must hack it
      #{
      #   split {
      #      inputField : record
      #      outputFields : [ts,raw,type,verb,resource,code,len,srcip,dstip,srcport,dstport,proto]
      #      separator : "\t"
      #      isRegex : false
      #      addEmptyStrings : true 
      #      trim : true
      #   }
      #}
      {
         java {
            imports : "import java.util.*;"
            code: """
               String[] fields = record.getFirstValue("record").toString().split("\t");
               String[] fieldNames = {"ts","raw","type","verb","resource","code","len","srcip","dstip","srcport","dstport","proto"};
               for (int i = 0; i < fieldNames.length; i++) {
                  if (fields[i] != null && !"".equals(fields[i])) { 
                     record.put(fieldNames[i], fields[i]);
                  }
               }
               
               record.removeAll("record");
               
               return child.process(record);
            """
         }
      }
      
      # Add a unique id field
      {
         generateUUID {
            field : id
         }
      }
      
      #{ logInfo { format : "post parse record {}", args : ["@{}"] } }
      
      # convert timestamp field to native Solr timestamp format
      # e.g. 2012-09-06T07:14:34Z to 2012-09-06T07:14:34.000Z
      {
        convertTimestamp {
          field : ts
          inputFormats : ["yyyy-MM-dd HH:mm:ss"]
          inputTimezone : UTC
#          outputFormat : "yyyy-MM-dd'T'HH:mm:ss.SSSZ"                                 
          outputTimezone : America/Los_Angeles
        }
      }

      #{ logInfo { format : "post ts conversion record {}", args : ["@{}"] } }

      # Command that sanitizes record fields that are unknown to Solr schema.xml by either 
      # deleting them (renameToPrefix is absent or a zero length string), or by moving them to a
      # field prefixed with the given renameToPrefix (e.g. renameToPrefix = "ignored_" to use 
      # typical dynamic Solr fields).
      #
      # Recall that Solr throws an exception on any attempt to load a document that contains a 
      # field that isn't specified in schema.xml.
      {
        sanitizeUnknownSolrFields {
          # Location from which to fetch Solr schema
          solrLocator : ${SOLR_LOCATOR}

          # renameToPrefix : "ignored_"
        }
      }

      # log the record at DEBUG level to SLF4J
      #{ logInfo { format : "post sanitize record {}", args : ["@{}"] } }

      # load the record into a Solr server or MapReduce Reducer.
      {
        loadSolr {
          solrLocator : ${SOLR_LOCATOR}
        }
      }
      
    ]
  }
]